[李天天 - 知乎 (zhihu.com)](https://www.zhihu.com/people/li-tian-tian-13/posts)
## 初探
**意义：让人们在保护数据隐私的同时完成计算任务。**
#### 什么是安全多方计算？
Secure Multi-party Computation, SMC
首先这是多方计算：每个participants有自己的数据集a，多方计算想得到函数f的输出。
显然我们需要去保障每一个参与者的数据隐私。
![[Pasted image 20240315204631.png]]
**应用场景：** 拍卖、病人数据、借贷

## 安全计算实现方法概览

简单的可以划分为两类：
1. 基于噪音：例如差分隐私，可以在数据，参数，输出加噪音。优点是效率高，缺点是结果不够准确，在复杂场景下结果可能无法使用。
![[Pasted image 20240315220315.png]]

2. 非噪音：一般是加密或编码。优点是不会干扰计算过程，结果将是准确值且有密码学理论加持，安全性有保障。缺点是计算量与通讯量可能很庞大。
3. 
![[Pasted image 20240315220345.png]]


## 差分隐私Differential Privacy

顾名思义，保护的是数据源中**微小改动**造成的隐私泄露问题。
形式化定义：相邻数据集，相邻集合
![[Pasted image 20240315221905.png]]

对于一个随机化算法A（随机化算法：对于特定输入，输出服从某一分布而不是固定值），相邻数据集的输出分布难以辨别。
![[Pasted image 20240315222022.png]]
<u>这也就是说算法如果作用于相邻数据集，得到输出O的概率差不多，这就达到了差分隐私的效果。也就是说，观察者根本看不出我们这一点微小的变化，无法辨别我们原始的样子，实现了保护隐私。</u>

#### 应用
前面说了这么多，那么怎么应用？最简单的方法：**加噪音** 
常用的是***拉普拉斯噪音***，它的数学性质和差分隐私很契合
![[Pasted image 20240315222613.png]]
不过实际应用中很难符合严格的概率定义，因此有一个放宽一点的定义：
这个δ是一个较小的常数，这种放宽的定义，适合用***高斯噪声*** 
![[Pasted image 20240315224857.png]]

场景：如果数据量大，噪声影响小可以放心用。数据量
小，噪声影响大就慎用。


## 混淆电路 Skip

## 密钥分享 Secret Sharing

**核心思想：将数字X拆分成多个数X1，X2...，当它们重新拼在一起就可以还原X。**
加法同态例子：
![[Pasted image 20240315233500.png]]

这个例子是所有人一起拼才可以有结果，如果有人掉线or作恶密码就废了，因此引申出来新的方法：<u>阈值密钥分享（threshold secret sharing）</u>
至少要有t个参与者才可以解开数据，比如Shamir的多项式解密
①生成一个t-1项的多项式，a1那些都是随机数
![[Pasted image 20240315233811.png]]
②给每个客户端分配f(1),f(2)...f(n)
③数学证明此时只需要t个人就可以解密

#### 乘法
直观的很好理解。但是复杂性的有待理解，原理大概懂

## 同态加密Homomorphic Encryption

形式化定义：
![[Pasted image 20240316003621.png]]
我们先给明文加密，然后扔去给某个节点执行，然后节点将执行后的密文返回

**典例：**
RSA算法
![[Pasted image 20240316003858.png]]
Paillier加密方案
![[Pasted image 20240316003905.png]]

过去的同态加密只支持简单场景的同态加密，无法加法和乘法一起用。就是这么简单的一个事情，直到2009年才有Gentry提出了基于bootstrapping的全同态加密方案。

最早的基础方法：
设有一个Bit为b(就是0或1)，
密文为c=b+2x+kp，p是就奇数密钥，x是噪音，k是随机数，因此C完全随机
此时c mod p = (b+2x) mod p，有个额外要求是b+2x小于等于p/2，否则奇偶性会反转。
奇奇怪怪的，反正就是x不能太大，不然结果不准确，也不能太小不然安全性太低。
![[Pasted image 20240316110011.png]]

显然不断的加密，x会越来越爆炸，尤其在乘法无法控制。等噪声到一定程度，密文再也无法破解了，我们称这种只能做一定次数的同态加密为**somewhat homomorphic encryption**

#### Bootstrapping
核心思想：每隔计几轮就更新一次密文，降噪为0，即解密后再加密。Gentry让解密过程本身也在密文情况下进行，就是说多次加密时的输入是密文的密文、密钥的密文。
在感觉噪音量快不可控时，换成另一套密文




## 零知识证明 Zero-Knowledge Proof

**零知识证明想要解决的问题是，让一方向另一方证明他知道某个问题的答案但却不想透露该问题的具体答案。**
角色：一个证明方Prover，验证方Verifier
eg：我知道有个人是凶手，但是我不知道他是谁、住哪、什么身份。重点是**零知识**
特性：
![[Pasted image 20240316112125.png]]

检验方法就是试探。试探强度不能太狠太偏，不然验证方产生歧义导致没有完备性，也不能太明显，不然被证明方发现规律，失去了可靠性，也不能试探太多内容，不然隐私暴露就不满足零知识性。

零知识验证方法三段论：
![[Pasted image 20240316112517.png]]
①根据论断内容发送交底材料给V
②V随机生成一个challenge
③P发送证明给V，循环多次

Eg：理论上在第一步可以全部发假的消息，但是成本很高而且还要与他人串供，一句谎言要一百句谎言弥补，这样的成本实在太高了。
![[Pasted image 20240316112802.png]]

更多Eg
显然例子2更换成其他合理函数也可以成立，注意u就是x。数学证明成立。
![[Pasted image 20240316114118.png]]

这些eg虽然美好，但是很多场景下双方未必有交互，就像区块链节点不一定一直在线，我们要给验证者自己找时间查验，因此我们需要***非交互式***的零知识证明。

这要求Prover生成的试探内容不能是提前预知的。Shamir的做法是证明方将连带交底材料在内的所有已知信息都做一个哈希，并以哈希值作为试探内容，生成证明，一起发给验证方。验证方也会验证该哈希值是否正确。如此一来，试探内容一方面可以由证明方自己生成，另一方面又因为和其他信息绑定了而无法随意篡改。
