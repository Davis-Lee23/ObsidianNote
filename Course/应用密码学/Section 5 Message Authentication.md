目的：收到消息要确保①由发送者发送 ②无人篡改

中间人攻击，AB发消息，有人冒充A或者B给对方发消息。

确保收到的消息确实是由假定的人发送的，叫做**Authentication**。

# DH密钥交换
p是大素数，g是Zp的二次剩余。
![[Pasted image 20241223145131.png]]

### 常用格式：
C = f（Ke，Data），encoding key
接收者验证布尔值g（Kv，Data，C），verification

MAC：message authentication code
对于私钥，有MAC。
对于公钥，有数字签名。

### 哈希强弱碰撞性
强：随机找到ab使得Ha=Hb很难
弱：给定a，找到一个b使得Ha=Hb很难
- **弱抗碰撞性**强调对已知哈希值寻找不同输入的困难性。
- **强抗碰撞性**强调对任何两个不同输入寻找相同哈希值的困难性。


# 常见哈希
MD5，128bit，几小时可以破解。
SHA-1，160bit，被破解。
SHA-256，SHA-512，未破解

# 数字签名
基于公钥的数据完整性技术。
数字签名是一种用于验证信息真实性和完整性的重要技术，广泛应用于信息安全领域。其主要功能包括**身份认证、数据完整性验证以及防止否认**。
数字签名是利用加密技术对电子文档或消息进行签名的一种方法。它类似于手写签名或印章，但使用的是数字算法。数字签名确保信息没有被篡改，同时确认信息的发送者身份。

基本元组：
![[Pasted image 20241223150201.png]]

KG是一个高效的key生成算法，生成PK，SK
签名：SK + M -> S
验证：PK + S +M -> {accept,reject}
我们要求私钥生成的签名肯定能被对应的公钥验证。

我们要求任何攻击者都不能伪造任何消息的签名。，Unforgeability


# RSA签名

密钥生成和RSA一样
![[Pasted image 20241223153323.png]]

说白了就是公钥解密，私钥加密，和正常算法反过来了
签名：和解密一样 S = m的d次方 % n
验证：像加密，当且仅当m = s的e次方 % n

![[Pasted image 20241223153731.png]]

在不知道陷门d的情况下，要找到e是很难的。

不过攻击者可以随机生成来破解，当然我们也可以加哈希抵抗，把m变成H（m）


# ElGamal 签名

密钥生成
![[Pasted image 20241223154956.png]]

签名与验证：
x的范围是0，p-1。
k不知道哪里来的，随便记吧
![[Pasted image 20241223155603.png]]


如果这个随便选择的g被敌手得知了，就可以伪造签名。
应对办法就是：
①不要重复用K
②确保0<r<p。
③确保g是随机生成的

应对存在伪造就是哈希。

### 类EG签名系列
签名是为了证明消息m的发送者知道私有的x。
因此核心是证明发送者知道x函数和m。
但是x函数和m不能直接是签名，因为敌手会计算。
因此签名者用随机因此保护函数x和m。
g的随机因子次方是签名的另一部分，这个随机因子受离散对数的硬度保护。